## chapter 01. 최적화란?

- 최적화(Optimization)

  - 웹 서비스의 성능을 개선하는 모든 행위를 일컫음
  - 아주 단순한 것부터 아주 어려운 방법까지 매우 다양함

- 일반적인 웹 서비스 최적화 방법

  - 서버의 응답속도 개선
  - 이미지, 폰트, 코드 파일 등의 정적 파일 로딩 개선
  - 불필요한 네트원크 요청 줄임 ..

- React App 내부의 최적화 방법
  - 컴포넌트 내부의 불필요한 연산 방지
  - 컴포넌트 내부의 불필요한 함수 재생성 방지
  - 컴포넌트의 불필요한 리렌더링 방지

<br>

## chpter 02. useMemo와 연산 최적화

- useMemo 란?
  - **메모이제이션** 기법을 기반으로 불필요한 연산을 최적화 하는 리액트 훅
    - 메모이제이션(Memoization) 이란? 기억해두기, 메모해두기 라는 뜻, 반복적으로 수행되는 동일한 연산을 최초로 실행했을 때 메모리에 결과값을 저장해두고 이 연산이 다시 필요해지면 다시 연산을 하지 않고 저장해둔 값으로 돌려주는 기법
  - useMemo 훅을 이용하면 메모이제이션 기법으로 특정 연산 값을 기억해 둘 수 있기 때문에 불필요한 연산을 방지하여 최적화 할 수 있다.
  - 자매품 : useCallback

```jsx
useMemo(() => {}, []);
```

- 인수 1. 콜백함수
  - 콜백함수가 반환하는 값을 useMemo가 그대로 다시 반환해준다.
- 인수 2. 의존성 배열 : deps
  - useEffect 처럼 deps에 포함된 값이 변경되었을 때에만 첫 번째 인수로 전달한 콜백함수를 다시 실행한다.

<br>

## chapter 03. React.memo와 컴포넌트 렌더링 최적화

React.memo로 불필요한 리렌더링 방지하기

### React.memo 란?

- 컴포넌트를 인수로 받아, 최적화된 컴포넌트로 만들어 반환
  ```jsx
  const MemoizedComponent = memo(Component);
  ```
- 최적화 된 컴포넌트는 Props를 기준으로 메모이제이션 됨
- 따라서 MemoizedComponent 는 부모 컴포넌트가 리렌더링 되더라도 자신이 받는 Props가 바뀌지 않으면 리렌더링 되지 않는다.

=> 메모이즈드 된 컴포넌트는 부모 컴포넌트가 리렌더링 되더라도 자신이 받는 props가 바뀌지 않으면 다시는 리렌더링 되지 않도록 메모이제이션 되기 때문에 불필요한 리렌더링이 방지되어서 자동으로 최적화가 이루어진다.

- 설정 시 경고가 뜨는 eslint의 "react-refresh/only-export-components" 규칙은 꺼버려도 무방

### 객체 타입 Props를 받는 경우 React.memo 최적화 방법

- 객체 타입(함수, 객체, 배열..)을 props로 받는 경우 React.memo 메서드를 적용하기만 한다고 해서 최적화가 제대로 이루어지지 않는다. (예시 : TodoItem vs Header) 객체 타입이 선언된 부모 컴포넌트가 리렌더링이 되면 객체 타입은 다시 생성되기 때문에 주소값이 달라지게 되므로 props를 얕은 비교로 판단하는 React.memo는 다른 값으로 인식하기 때문이다.
- 해결 방법 1. Props로 받는 객체 타입들(함수, 배열, 객체..)을 useCallback 을 이용하여 메모이제이션 하기. -> chapter 03에서...
- 해결 방법 2. React.memo 의 두번째 인수에 콜백 함수를 전달하여 최적화 커스텀 하기✅

### 콜백 함수로 React.memo 최적화 커스텀 하기

- (보통 콜백 함수를 생략하지만) 콜백 함수를 전달하면 이제 memo 메서드는 부모 컴퍼넌트가 리렌더링 될 때마다 컴포넌트의 props가 바뀌었는지를 스스로 판단하지 않고 콜백함수의 반환값에 따라서 판단한다.
- true를 반환하면 props가 바뀌었다고 판단하여 리렌더링을 하지 않고, false를 반환하면 props가 바뀌었다고 판단하여 리렌더링 한다.

```jsx
memo(컴포넌트, (prevProps, nextProps) => {
  // 매개변수로 이전의 props와 새로운 props를 받는다. -> 이 둘을 이용한 조건식으로 렌더링 여부 커스텀이 가능하다.
  // 반환값에 따라, Props가 바뀌었는지 안바뀌었는지 판단
  // True 반환 -> Props 바뀌지 않음 -> 리렌더링 X
  // False 반환 -> Props 바뀜 -> 리렌더링 O
});
```

### 고차 컴포넌트 (HOC; Higher Order Component)

- 컴포넌트를 인수로 받아서 해당 컴포넌트에 최적화나 메모이제이션 같은 추가적인 기능을 덧붙여서 기능이 추가된 새로운 컴포넌트를 반환해주는 React.memo 같은 메서드들을 리액트에서는 고차 컴포넌트라고 부른다.
- 고차 컴포넌트를 이용하면 컴포넌트에 새로운 기능을 부여할 수 있기 때문에 복잡한 리액트 앱을 구축할 때 자주 쓰이는 방식이다.
- 고차 컴포넌트는 우리가 직접 만들수도 있다. 🔗 [참고자료 링크](https://patterns-dev-kr.github.io/design-patterns/hoc-pattern/)

<br>

## chapter 04. useCallback과 함수 재생성 방지

- React.memo 메서드는 props의 변경을 얕은 비교로 판단하기 때문에 함수 같은 객체 타입을 props로 받을 경우 최적화가 이루어지지 않아서 우리가 별도로 콜백 함수를 작성하여 커스텀 해줘야 했다. 하지만 이 경우 props를 하나하나 지정해줘야 하고, props의 이름이 바뀌거나 새로운 props가 추가되거나 기존 props가 삭제되면 함께 수정해줘야하는 불편함이 있다.
- 따라서 props 중 객체 타입의 개수가 더 적을 경우, 객체 타입이 (리렌더링 되어도) 다시 생성되지 않도록 하는게 더 편리한 방법이다. 이 때 useCallback 이라는 리액트 훅을 사용한다.

### useCallbak 사용하기

```jsx
const func = useCallback(() => {}, []);
```

- 인수 1. 최적화 하는 함수
  - 재생성 되지 않도록 방지하는 함수
  - 이 함수는 useCallback이 그대로 반환하기 때문에 변수에 담아서 쓸 수 있다.
- 안수 2. deps
  - depth가 변경되었을 때만 함수를 다시 생성한다.
  - 빈 배열로 두면 컴포넌트가 마운트 될 때 딱 한 번만 생성하고 그 뒤에는 새롭게 생성 되지 않는다.

## 최적화의 기준

### 1. 최적화는 언제 하면 좋은가?

- 너무 이른 타이밍에 하거나 너무 많은 것을 하려해도 문제가 될 수 있다.
- 보통 프로젝트를 거의 완성한 뒤에 한다.
- 즉, 기능 구현이 먼저이고 기능이 완성되면 그 뒤에 최적화를 하는 게 일반적인 방법이다.
- useCallback을 적용해 놓은 후에 함수에 새로운 기능을 덧붙이거나 기능을 수정하면 최적화가 풀리거나 아예 기능이 고장나 버리는 경우도 생기기 때문이다.

### 2. 어떤 것들이 최적화의 대상이 되어야 하는가?

- 모든 것에 최적화 적용 ❌
- 꼭 최적화가 필요할 것 같은 연산, 함수, 컴포넌트에만 적용하는 것이 좋다.
- 최적화에도 props의 값을 비교한다던가 메모이제이션을 위해 메모리에 컴포넌트 결과값을 보관해둔다던가하는 연산들이 필요하다.
- 따라서 헤더나 푸터처럼 매우 단순히 UI를 렌더링하는 컴포넌트는 최적화 하는 연산보다 그냥 리렌더링 시키는게 더 빠를 수도 있다.
  ToDoItem 컴포넌트처럼 유저의 행동에 따라서 개수가 굉장히 많아질 수 있는 컴포넌트라던가 또는 함수를 굉장히 많이 가지고 있어서 코드가 좀 무거운 컴포넌트 같은 것들에 한해서만 최적화를 수행하는 것을 권장한다.

  <br>

🔗 **최적화 관련 유용한 컨텐츠** :
[아티클 "When to use useMemo, useCallback"](https://goongoguma.github.io/2021/04/26/When-to-useMemo-and-useCallback/)
